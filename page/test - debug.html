<!doctype html>
<html lang="zh-hans">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width" />

<meta name="renderer" content="webkit" />
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />

<title>xj.ripple - debug</title>
</head>
<body style="font-family:Iosevka,'Microsoft YaHei','Hiragino Sans GB';max-width:768px;">
<style>@font-face{font-family:"Iosevka";src:local('Iosevka'), url("../static/font/iosevka/6.1.2/iosevka-fixed-regular.woff2") format("woff2"), url("../static/font/iosevka/6.1.2/iosevka-fixed-regular.woff") format("woff");}</style>



<section>
<h1 style="margin-top:0;">xj.ripple - debug</h1>
<p>样式内容比较多，就不放出来占地方了，以后按钮伪类的设置可参考下面这个 style 里的写法。</p>

<style>
/* styleContent */
/* 按钮阴影涉及到层级和聚焦等问题，并且就逻辑上来讲悬停改变层级也不大对，还是得选择使用悬停改变背景色的传统做法 */
/* .button:hover{box-shadow:0 2px 4px rgba(0,0,0,0.5), 0 4px 8px rgba(0,0,0,0.25);} */
/* .button:active{box-shadow:0 0 0 transparent;} */

*{box-sizing:border-box;}
hr{margin:32px 0;}

.box{display:inline-block;padding:4px;min-width:64px;min-height:64px;border:1px solid #ccc;vertical-align:top;}
.button{display:inline-block;padding:0 12px;height:40px;border:1px solid #ccc;border-radius:4px;vertical-align:middle;line-height:38px;cursor:pointer;transition:background-color 250ms,box-shadow 250ms;-webkit-appearance:none;}

.button-primary{border-color:transparent;background-color:#39f;color:#fff;}
.button-success{border-color:transparent;background-color:#0c3;color:#fff;}
.button-warning{border-color:transparent;background-color:#f93;color:#fff;}
.button-danger {border-color:transparent;background-color:#f33;color:#fff;}
.button-extra  {border-color:transparent;background-color:#93f;color:#fff;}
.button-info   {border-color:transparent;background-color:#099;color:#fff;}

html:not(.xj-operate-touch) .button:hover        {background-color:#f0f0f0;}
html:not(.xj-operate-touch) .button-primary:hover{background-color:#248af0;}
html:not(.xj-operate-touch) .button-success:hover{background-color:#00bd24;}
html:not(.xj-operate-touch) .button-warning:hover{background-color:#f08a24;}
html:not(.xj-operate-touch) .button-danger:hover {background-color:#f02424;}
html:not(.xj-operate-touch) .button-extra:hover  {background-color:#8a24f0;}
html:not(.xj-operate-touch) .button-info:hover   {background-color:#008a8a;}
</style>

<hr />
</section>



<section>
<h2>配合按钮使用</h2>
<p>当按钮使用了 xj-ripple 的效果时，按钮的相关样式设置可以参考本文件的写法，鼠标在 hover 状态下调整背景色，rgb 的值各减 f(16)，并且有 xj-ripple 的效果，就不再需要为按钮设置 :active{} 伪类样式了。</p>

<p>
	<span class="button xj-ripple">					button	</span>
	<span class="button button-primary xj-ripple">	button	</span>
	<span class="button button-success xj-ripple">	button	</span>
	<span class="button button-warning xj-ripple">	button	</span>
	<span class="button button-danger xj-ripple">	button	</span>
	<span class="button button-extra xj-ripple">	button	</span>
	<span class="button button-info xj-ripple">		button	</span>
</p>

<hr />
</section>



<section>
<h2>预设值的颜色</h2>
<p>波纹颜色由 background-color 和 box-shadow 这两个样式决定，但它们的值其实都是 currentColor，也就是说，波纹的颜色其实最终是取决于 color 样式的设置，在默认的情况下，波纹的颜色和文本的颜色相同。</p>
<p>xj.ripple.css 文件中预设置了 8 种颜色，分别为 xj-ripple-primary, xj-ripple-success, xj-ripple-warning, xj-ripple-danger, xj-ripple-extra, xj-ripple-info, xj-ripple-white, xj-ripple-black。</p>

<p>
	<span class="box xj-ripple xj-ripple-primary">	xj-ripple<br />xj-ripple-primary	</span>
	<span class="box xj-ripple xj-ripple-success">	xj-ripple<br />xj-ripple-success	</span>
	<span class="box xj-ripple xj-ripple-warning">	xj-ripple<br />xj-ripple-warning	</span>
	<span class="box xj-ripple xj-ripple-danger">	xj-ripple<br />xj-ripple-danger		</span>
</p>

<p>
	<span class="box xj-ripple xj-ripple-extra">	xj-ripple<br />xj-ripple-extra		</span>
	<span class="box xj-ripple xj-ripple-info">		xj-ripple<br />xj-ripple-info		</span>
	<span class="box xj-ripple xj-ripple-white">	xj-ripple<br />xj-ripple-white		</span>
	<span class="box xj-ripple xj-ripple-black">	xj-ripple<br />xj-ripple-black		</span>
</p>

<hr />
</section>



<section>
<h2>基础类名检测</h2>
<p>插件共有 4 个基础类名，.xj-ripple 不允许波纹溢出，.xj-ripple-out 允许波纹溢出，.xj-ripple-mid 不允许波纹溢出且波纹将自动水平垂直居中，.xj-ripple-out-mid 类名则是允许波纹溢出且波纹会自动居中。</p>
<p>
	<span class="box xj-ripple">			xj-ripple			</span>
	<span class="box xj-ripple-out">		xj-ripple-out		</span>
	<span class="box xj-ripple-mid">		xj-ripple-mid		</span>
	<span class="box xj-ripple-out-mid">	xj-ripple-out-mid	</span>
</p>

<h2>委托绑定检测</h2>
<p>检测委托绑定的响应，由于事件采用了捕获的形式进行绑定，所以并不需要担心 event.target 会是其他的标签，捕获时顺序从上到下，肯定会先捕获到第一个 .xj-ripple-* 类名的标签，而不是捕获到其他的子元素。</p>
<p>
	<span class="box xj-ripple">			xj-ripple			<br /><span class="box">click</span></span>
	<span class="box xj-ripple-out">		xj-ripple-out		<br /><span class="box">click</span></span>
	<span class="box xj-ripple-mid">		xj-ripple-mid		<br /><span class="box">click</span></span>
	<span class="box xj-ripple-out-mid">	xj-ripple-out-mid	<br /><span class="box">click</span></span>
</p>

<h2>标签嵌套检测</h2>
<p>由于是捕获绑定，从上到下进行，所以事件并不会重复触发，也就是说标签嵌套也没问题，即使 .xj-ripple-* 的元素中又嵌套了 .xj-ripple-* 元素，也不会相互起冲突，在哪里点击，就会在那个容器中响应波纹的。</p>
<p>
	<span class="box xj-ripple">			xj-ripple			<br /><span class="box xj-ripple">			xj-<br />ripple			</span></span>
	<span class="box xj-ripple-out">		xj-ripple-out		<br /><span class="box xj-ripple-out">		xj-<br />ripple-out		</span></span>
	<span class="box xj-ripple-mid">		xj-ripple-mid		<br /><span class="box xj-ripple-mid">		xj-<br />ripple-mid		</span></span>
	<span class="box xj-ripple-out-mid">	xj-ripple-out-mid	<br /><span class="box xj-ripple-out-mid">	xj-<br />ripple-out-mid	</span></span>
</p>

<hr />
</section>



<section>
<h2>debug : false</h2>
<p>波纹执行后，ripple 和 offset 节点会被自动移除，如果该参数为 true，则不会自动移除节点，方便测试。</p>

<p>
	<span class="box xj-ripple" xj-ripple="{debug:true }">debug:true</span>
</p>

<hr />
</section>



<section>
<h2>append : true</h2>
<p>ripple 和 offset 节点会被添加到容器的最后面，如果该参数为 false，则节点会被添加到容器的最前面。</p>

<p>
	<span class="box xj-ripple" xj-ripple="{append:true}">	<i></i>append:true	</span>
	<span class="box xj-ripple" xj-ripple="{append:false}">	<i></i>append:false	</span>
</p>

<hr />
</section>



<section>
<h2>mouse : [0]</h2>
<p>默认响应鼠标左键，如果想响应中键和右键，那么可将 1, 2 添加进数组，该参数对 touch 触屏设备无效。</p>

<p>
	<span class="box xj-ripple" xj-ripple="{mouse:[0]}">		mouse:[0]<br />只响应左键		</span>
	<span class="box xj-ripple" xj-ripple="{mouse:[0,1]}">		mouse:[0,1]<br />响应左键中键	</span>
	<span class="box xj-ripple" xj-ripple="{mouse:[0,1,2]}">	mouse:[0,1,2]<br />响应左中右键	</span>
</p>

<hr />
</section>



<section>
<h2>forbid : true</h2>
<p>当标签设置了 disabled 属性或 .xj-ripple-disabled 类名或 cursor:not-allowed; 样式，标签被点击将不会响应波纹，当标签的上层标签有这些属性类名样式时，标签被点击也不会响应波纹，但如果 forbid 被设置为 false，则标签的上层标签有这些属性类名，子标签不受影响，还是会响应的，唯一例外的是 cursor:not-allowed 属性，这个属性会自动被子元素继承，所以即使设置了 forbid : false，子元素依旧不响应波纹。</p>

<p>
	<span class="box xj-ripple" disabled="disabled">		设置了 <br />disabled 属性					</span>
	<span class="box xj-ripple xj-ripple-disabled">			设置了 <br />xj-ripple-disabled 类名		</span>
	<span class="box xj-ripple" style="cursor:not-allowed;">设置了 <br />cursor:not-allowed 指针样式	</span>
</p>

<p>
	<span class="box" disabled="disabled">			<span class="box xj-ripple">父元素设置了 <br />disabled 属性<br />所以子元素不响应					</span></span>
	<span class="box xj-ripple-disabled">			<span class="box xj-ripple">父元素设置了 <br />xj-ripple-disabled 类名值<br />所以子元素不响应		</span></span>
	<span class="box" style="cursor:not-allowed;">	<span class="box xj-ripple">父元素设置了 <br />cursor:not-allowed 指针样式<br />所以子元素不响应	</span></span>
</p>

<p>
	<span class="box" disabled="disabled">	<span class="box xj-ripple" xj-ripple="{forbid:false}">父元素虽然被设置了 <br />disabled 属性<br />但子元素的 forbid = false<br />所以不受影响，还是可以响应				</span></span>
	<span class="box xj-ripple-disabled">	<span class="box xj-ripple" xj-ripple="{forbid:false}">父元素虽然被设置了 <br />xj-ripple-disabled 类名值<br />但子元素的 forbid = false<br />所以不受影响，还是可以响应	</span></span>
</p>

<p>
	<span class="box" style="cursor:not-allowed;"><span class="box xj-ripple" xj-ripple="{forbid:false}">父元素设置了 <br />cursor:not-allowed 指针样式<br />子元素总是会受到影响，无法响应波纹效果<br />因为这样式会自动继承，除非为设置其他的 cursor</span></span>
</p>
<hr />
</section>



<section>
<h2>inherit : true</h2>
<p>设置了波纹的标签，可以通过为标签或标签的父级标签设置内联的 xj-ripple="{}" 属性来设置波纹的各种参数，而 inherit 参数是用于控制这个内联属性是否要实现继承，该参数默认为 true，也就是会自动的继承。</p>
<p>当标签和标签的父级标签都设置了该参数时，层级越低的标签，属性权重就越高，这种内联属性继承，最大的好处是，如果想为某个区域的波纹设置特殊参数，不需要逐个标签设置，只需要设置父容器，然后继承即可。</p>

<p>
	<span class="box xj-ripple" xj-ripple="{opacity:'0.75'}">opacity:'0.75'</span>
</p>

<p>
	<span class="box" xj-ripple="{opacity:'0.75'}">opacity:'0.75'<br />
		<span class="box xj-ripple" xj-ripple="{radius:'0%', color:'red'}">radius:'0%', color:'red'</span>
	</span>
</p>

<p>
	<span class="box" xj-ripple="{opacity:'0.75'}">opacity:'0.75'<br />
		<span class="box" xj-ripple="{radius:'0%'}">radius:'0%'<br />
			<span class="box xj-ripple" xj-ripple="{color:'red'}">color:'red'<br />属性继承</span>
			<span class="box xj-ripple" xj-ripple="{radius:'50%'}">radius:'50%'<br />继承被覆盖</span>
			<span class="box xj-ripple" xj-ripple="{inherit:false}">inherit:false<br />不继承的情况</span>
		</span>
	</span>
</p>

<hr />
</section>



<section>
<h2>nodeName : 'xj-ripple'</h2>
<p>该参数用于设置波纹节点的标签名称，之所以使用自定义的标签，是为了避免被标签选择器误选，在下例中，为了方便查看波纹节点的标签，我们还特意设置了 debug:true，这样的话节点就不会自动移除，方便检测。</p>

<p><span class="box xj-ripple" xj-ripple="{debug:true, nodeName:'xj-ripple'}">debug:true<br />nodeName:'xj-ripple'</span></p>

<p><span class="box xj-ripple" xj-ripple="{debug:true, nodeName:'custom-node-name'}">debug:true<br />nodeName:'custom-node-name'</span></p>

<hr />
</section>



<section>
<h2>classString : ''</h2>
<p>
	<span class="box xj-ripple" xj-ripple="{debug:true}">									debug:true<br />default							</span>
	<span class="box xj-ripple" xj-ripple="{debug:true, classString:'testClass'}">			debug:true<br />classString:'testClass'			</span>
</p>

<h2>styleString : ''</h2>
<p>
	<span class="box xj-ripple" xj-ripple="{debug:true}">									debug:true<br />default							</span>
	<span class="box xj-ripple" xj-ripple="{debug:true, styleString:'font-size:16px;'}">	debug:true<br />styleString:'font-size:16px;'	</span>
</p>

<hr />
</section>



<section>
<h2>opacity : '0.375'</h2>
<p>
	<span class="box xj-ripple">								default				</span>
	<span class="box xj-ripple" xj-ripple="{opacity:'1'}">		opacity:'1'			</span>
</p>

<h2>radius : '50%'</h2>
<p>
	<span class="box xj-ripple">								default				</span>
	<span class="box xj-ripple" xj-ripple="{radius:'0%'}">		radius:'0%'			</span>
</p>

<h2>color : 'currentColor'</h2>
<p>
	<span class="box xj-ripple">								default				</span>
	<span class="box xj-ripple" xj-ripple="{color:'red'}">		color:'red'			</span>
</p>

<hr />
</section>



<section>
<h2>height : 'auto' / width : 'auto'</h2>
<p>
	<span class="box xj-ripple-out" xj-ripple="{width:'50px',height:'50px'}">width:'50px',<br />height:'50px'</span>
	<span class="box xj-ripple-out" xj-ripple="{width:'50%', height:'50%' }">width:'50%', <br />height:'50%' </span>
</p>

<h2>minWidth : '0px' / minHeight : '0px'</h2>
<p>
	<span class="box xj-ripple-out" xj-ripple="{minWidth:'200px',minHeight:'200px'}">minWidth:'200px',<br />minHeight:'200px'</span>
	<span class="box xj-ripple-out" xj-ripple="{minWidth:'200%', minHeight:'200%' }">minWidth:'200%', <br />minHeight:'200%' </span>
</p>

<h2>maxWidth : 'none' / maxHeight : 'none'</h2>
<p>
	<span class="box xj-ripple-out" xj-ripple="{maxWidth:'50px',maxHeight:'50px'}">maxWidth:'50px',<br />maxHeight:'50px'</span>
	<span class="box xj-ripple-out" xj-ripple="{maxWidth:'50%', maxHeight:'50%' }">maxWidth:'50%', <br />maxHeight:'50%' </span>
</p>

<h2>extraWidth : '0px' / extraHeight : '0px'</h2>
<p>
	<span class="box xj-ripple-out" xj-ripple="{width:'50px',height:'50px',extraWidth:'50px',extraHeight:'50px'}">width:'50px'<br />height:'50px'<br />extraWidth:'50px'<br />extraHeight:'50px'</span>
	<span class="box xj-ripple-out" xj-ripple="{width:'50%', height:'50%', extraWidth:'50%', extraHeight:'50%' }">width:'50%' <br />height:'50%' <br />extraWidth:'50%' <br />extraHeight:'50%' </span>
</p>

<hr />
</section>



<section>
<h2>left : 'auto' / top : 'auto'</h2>
<p>
	<span class="box xj-ripple-out" xj-ripple="{left:'0px',top:'0px'}">left:'0px',<br />top:'0px'</span>
	<span class="box xj-ripple-out" xj-ripple="{left:'50%',top:'50%'}">left:'50%',<br />top:'50%'</span>
</p>

<h2>offsetLeft : '0px' / offsetTop : '0px'</h2>
<p>
	<span class="box xj-ripple-out" xj-ripple="{left:'0px',top:'0px',offsetLeft:'5px',offsetTop:'5px'}">left:'0px'<br />top:'0px'<br />offsetLeft:'5px'<br />offsetTop:'5px'</span>
	<span class="box xj-ripple-out" xj-ripple="{left:'50%',top:'50%',offsetLeft:'50%',offsetTop:'50%'}">left:'50%'<br />top:'50%'<br />offsetLeft:'50%'<br />offsetTop:'50%'</span>
</p>

<hr />
</section>



<section>
<h2>
	transitionProperty : 'transform, opacity'<br />
	transitionDuration : '500ms'<br />
	transitionTimingFunction : 'ease-out'<br />
	transitionDelay : '0ms, 125ms'<br />
</h2>

<p>
	<span class="box xj-ripple" xj-ripple="{debug:true}">
		debug:true<br />
		default<br />
	</span>
</p>

<p>
	<span class="box xj-ripple" xj-ripple="{debug:true,
		transitionProperty:'opacity, transform',
		transitionDuration:'250ms',
		transitionTimingFunction:'ease',
		transitionDelay:'0ms'
	}">
		debug:true<br />
		transitionProperty:'opacity, transform'<br />
		transitionDuration:'250ms'<br />
		transitionTimingFunction:'ease'<br />
		transitionDelay:'0ms'<br />
	</span>
</p>

<hr />
</section>



<section>
<h2>specialRatio : 1.5</h2>
<p>specialRatio 参数用于设置 .xj-ripple-mid 和 .xj-ripple-out-mid 模式下波纹的直径，默认值是容器最长那条边的 1.5 倍，一般是能覆盖到整个容器的(不含 border)，下例为了方便观察，使用 out-mid 模式。</p>

<p>
	<span class="box xj-ripple-out-mid">								default			</span>
	<span class="box xj-ripple-out-mid" xj-ripple="{specialRatio:1}">	specialRatio:1	</span>
	<span class="box xj-ripple-out-mid" xj-ripple="{specialRatio:2}">	specialRatio:2	</span>
</p>

<hr />
</section>



<section>
<h2>insertTarget = 'auto'</h2>
<p>用 insertTarget 参数将波纹插入到其他容器中，如果没有设置 left / top 或 offsetLeft / offsetTop 参数，则波纹圆心默认总是在目标容器的中间，波纹参数只会在触发点击的那个节点上获取，与波纹的目标容器并没有关系，目标容器所需要做的，就是设置 position 样式不为 static，以此确保波纹能实现绝对定位。</p>

<p>
	<span class="box xj-ripple" xj-ripple="{insertTarget:'self i'}">
		span[class="box xj-ripple"]<br />[xj-ripple="{insertTarget:'self i'}"]<br />
		<i class="box" style="position:relative;overflow:hidden;">波纹将在这里响应<br />position:relative;<br />overflow:hidden;</i>
	</span>
	<span class="box xj-ripple-out-mid" xj-ripple="{insertTarget:'self i'}">
		span[class="box xj-ripple-out-mid"]<br />[xj-ripple="{insertTarget:'self i'}"]<br />
		<i class="box" style="position:relative;overflow:visible;">波纹将在这里响应<br />position:relative;<br />overflow:visible;</i>
	</span>
</p>

<p>
	<span class="box">parent<br />
		<span class="box xj-ripple" xj-ripple="{insertTarget:'parent i'}">
			span[class="box xj-ripple"]<br />[xj-ripple="{insertTarget:'parent i'}"]<br />
			<i class="box" style="position:relative;overflow:hidden;">波纹将在这里响应<br />position:relative;<br />overflow:hidden;</i>
		</span>
	</span>
	<span class="box">parent<br />
		<span class="box xj-ripple-out-mid" xj-ripple="{insertTarget:'parent i'}">
			span[class="box xj-ripple-out-mid"]<br />[xj-ripple="{insertTarget:'parent i'}"]<br />
			<i class="box" style="position:relative;overflow:visible;">波纹将在这里响应<br />position:relative;<br />overflow:visible;</i>
		</span>
	</span>
</p>

<p>
	<span class="box xj-ripple" xj-ripple="{insertTarget:'#insertTag01'}">
		span[class="box xj-ripple"]<br />[xj-ripple="{insertTarget:'#insertTag01'}"]<br />
		<i class="box" id="insertTag01" style="position:relative;overflow:hidden;">波纹将在这里响应<br />#insertTag01<br /> </i>
	</span>
	<span class="box xj-ripple-out-mid" xj-ripple="{insertTarget:'#insertTag02'}">
		span[class="box xj-ripple-out-mid"]<br />[xj-ripple="{insertTarget:'#insertTag02'}"]<br />
		<i class="box" id="insertTag02" style="position:relative;">波纹将在这里响应<br />#insertTag02</i>
	</span>
</p>

<p>
	<span class="box xj-ripple" xj-ripple="{insertTarget:function(target){ return target.querySelector('b') }}">
		span[class="box xj-ripple"]<br />
		[xj-ripple="{insertTarget:function(target)<br />
		{ return target.querySelector('b'); }, }"]<br />
		<i class="box" style="position:relative;">i</i><b class="box" style="position:relative;">b</b>
	</span>
</p>

<hr />
</section>



<section>
<h2>createBefore = 'function(){}'</h2>
<p><span class="box xj-ripple" xj-ripple="{createBefore:function(event,element){ console.log(event,element) }}">{createBefore:<br />function(event,element){ console.log(event,element) }}</span></p>

<h2>createAfter = 'function(){}'</h2>
<p><span class="box xj-ripple" xj-ripple="{createAfter:function(event,element){ console.log(event,element) }}">{createAfter:<br />function(event,element){ console.log(event,element) }}</span></p>

<h2>removeCallback = 'function(){}'</h2>
<p><span class="box xj-ripple" xj-ripple="{removeCallback:function(event,element){ console.log(event,element) }}">{removeCallback:<br />function(event,element){ console.log(event,element) }}</span></p>

<hr />
</section>



<section>
<h2>xj.ripple.create()</h2>

<p>
	<button id="button01" type="button" onclick="xj.ripple.create(document.getElementById('span01'), {debug:true});">点击将会在下面的 span 中生成 ripple</button><br />
	<span id="span01" class="box" style="position:relative;"></span>
</p>

<p>
	<button id="button02" type="button" onclick="xj.ripple.create(document.getElementById('span02'), {debug:true});">点击将会在下面的 span 中生成 ripple</button><br />
	<span id="span02" class="box xj-ripple"></span>
</p>

<hr />
</section>



<section>
<h2>单标签元素</h2>
<p>单标签元素，例如 img 或 input，由于它们不允许子标签的存在，所以也无法在这类标签中实现点击波纹效果。但是非要实现这个效果，也可以将单标签嵌在一个双标签之中(例如 div)，然后将类名添加在 div 上。</p>

<p>
无嵌套的情况：<br />
<img class="xj-ripple" style="display:inline-block;vertical-align:middle;" src="../static/image/64x64.gif" />
<input class="xj-ripple-mid" style="display:inline-block;vertical-align:middle;" type="button" value="input[type=&quot;button&quot;]" />
</p>

<p>
嵌套了的情况：<br />
<span class="xj-ripple" style="display:inline-block;vertical-align:middle;" >
	<img style="display:inline-block;vertical-align:middle;" src="../static/image/64x64.gif" />
</span>
<span class="xj-ripple-mid" style="display:inline-block;vertical-align:middle;" >
	<input style="display:inline-block;vertical-align:middle;" type="button" value="input[type=&quot;button&quot;]" />
</span>
</p>

<hr />
</section>



<section>
<h2>存在边框和边距的元素</h2>
<p>经过测试可以发现，margin 对于定位并没有影响，但 border 和 scrollbar 则会影响到定位，得把这些问题考虑上，当滚动条出现在左上角时，只有靠 offsetNode 的 DOMRect 才能准确的获取到容器的左上角位置。</p>
<p>实测发现，当滚动条在左侧时，Win10 的 IE11/18 会出现波纹漂移的情况，目前还不知道这是否为虚拟系统的 BUG，但一般波纹不会在有滚动条的容器中使用，且滚动条在左侧的情况很少见，所以这 BUG 暂时搁置。</p>

<div style="display:inline-block;border:1px solid #ccc;vertical-align:top;">
	<div id="div01" style="position:relative;border:10px solid #ccc;margin:10px;padding:10px;overflow-y:scroll;direction:rtl;unicode-bidi:bidi-override;" class="xj-ripple" xj-ripple="{width:'32px',height:'32px',debug:true}">
		<div id="div02" style="position:relative;border:10px solid #ccc;margin:10px;padding:10px;overflow-y:scroll;direction:rtl;unicode-bidi:bidi-override;" class="xj-ripple" xj-ripple="{width:'32px',height:'32px',debug:true}">
			<div id="div03" style="position:relative;border:10px solid #ccc;margin:10px;padding:10px;overflow-y:scroll;direction:rtl;unicode-bidi:bidi-override;" class="xj-ripple" xj-ripple="{width:'32px',height:'32px',debug:true}">
				click
			</div>
		</div>
	</div>
</div>

<hr />
</section>



<section>
<h2>xj.ripple 不支持在 svg 标签上使用</h2>
<p>svg 标签无法容纳普通的标签作为子元素，强行设置也不行的，所以 ripple 也无法在 svg 标签中使用，就算用 createElementNS() 方法创建 svg 标签，定位和阴影等样式也难以设置，所以这功能只能暂时搁置了。</p>

<svg class="xj-ripple" xj-ripple="{debug:true}" style="width:100%;max-width:768px;height:200px;border:1px solid #ccc;"></svg>

<hr />
</section>



<section>
<h2>在一个节点上同时触发多个 touch 事件响应波纹</h2>
<p>V0.2.4 开始支持在移动端多点触屏的情况下同时响应多个波纹效果，不管多点触屏的是否为同个元素都可以成功响应，但大前提是没有触发 touchmove 事件，一旦触发了该事件，将不被视为点击，波纹也就不响应。</p>

<div id="container" class="xj-ripple" style="width:100%;max-width:768px;height:200px;border:1px solid #ccc;">id="container"</div>
<div>id="result" : <span id="result">0</span></div>

<hr />
</section>



<script>
// 可在引入插件前通过 xj.rippleConfig['0.3.0'] = {} 来设置插件的全局配置，注意版本号要对得上才行
// if(window.xj === undefined){ xj = {} };
// if(xj.rippleConfig === undefined){ xj.rippleConfig = {} };
// xj.rippleConfig['0.3.0'] = {
//
//	// 要添加 existClass 类名的目标节点，默认是 html 标签节点，之所以不是 body，是因为插件在初始化时 body 标签可能还未加载，不推荐修改
//	classTarget : document.documentElement,
//	
//	// 初始化后 targetClass 元素节点会被添加这个参数的类名，默认是 'xj-ripple-exist'，这个可用于 CSS 判断环境中是否存在 xj.ripple 插件
//	existClass : 'xj-ripple-exist',
//	
//	// 当元素节点符合 defaultClass 字符串参数中的任意一个选择器，那么点击的时候就会响应波纹效果，默认值为 '.xj-ripple, .xj-ripple-out'
//	// '.xj-ripple' 与 '.xj-ripple-out' 的区别在于，前者的波纹不会溢出，而后者的波纹会溢出，溢出只用于测试，正式环境中很少会用到该效果
//	// 如果希望某些元素，例如 button，默认就带波纹效果，可以将 'button' 添加到这个分组选择器中，这样就不需要对每个 button 都设置类名了
//	// 当然你得为 button 标签设置 position:relative; 或 position:absolute;，否则波纹无法相对定位，而 overflow:hidden; 设置则不是必须的
//	defaultClass : '.xj-ripple, .xj-ripple-out',
//	
//	// 与 defaultClass 参数类似，符合这个选择器的元素，点击所产生的波纹会水平垂直居中定位，默认为 '.xj-ripple-mid, .xj-ripple-out-mid'
//	// 希望某元素自带这种波纹，也可以将选择器以分组选择器的形式追加到参数中，注意该元素不能是 position:static;，否则波纹将无法准确定位
//	specialClass : '.xj-ripple-mid, .xj-ripple-out-mid',
//	
// };



// 可在引入插件前通过 xj.rippleOption['0.3.0'] = {} 来设置插件实例的参数，注意版本号要对得上才行
// if(window.xj === undefined){ xj = {} };
// if(xj.rippleOption === undefined){ xj.rippleOption = {} };
// xj.rippleOption['0.3.0'] = {
//	
//	debug : false,									// 进入调试模式，默认为 false，如果将该属性设置为 true 则触发 mouseup 事件或 touchend 事件之后，不会自动删除插件生成的节点，这样方便进行开发调试
//	append : true,									// 波纹追加模式，默认是 true，也就是将 ripple 波纹标签写入到目标容器里的最后面，如果这个参数设置为 false，则是将波纹标签写入到目标容器里的最前面
//	
//	mouse : [0],									// 响应鼠标按键，默认是 [0]，也就是只有点击左键才会响应，数值 012 分别代表鼠标左键中键右键，希望中键右键也响应，可以将数值添加进数组
//	forbid : true,									// 自动禁止响应，默认是 true，也就是当目标所在的上层标签有 disabled 属性或 xj-ripple-disabled 类名或 cursor:not-allowed 样式则不响应
//	inherit : true,									// 自动继承属性，默认是 true，也就是如果元素的上层标签设置了 xj-ripple="{}" 属性，那么这个属性会被子元素继承，除非子元素自己也设置了
//	
//	nodeName : 'xj-ripple',							// 波纹标签名称，默认是 'xj-ripple'，之所以使用自定义的标签名称生成节点，是为了避免节点被常规的标签选择器样式影响到
//	
//	classString : '',								// 波纹标签上额外的类名，默认是空 ''，多个值可用空格隔开，例如 'col-success bg-warning rad4px'
//	styleString : '',								// 波纹标签上额外的样式，默认是空 ''，类似内联样式的写法，例如 'border:2px;border-radius:4px;'
//	
//	opacity : '0.375',								// 设置波纹透明度(opacity)，默认是 '0.375'，这里其实用 Number 类型值也行，结果并没有什么区别的
//	radius : '50%',									// 设置波纹的圆角(border-radius)，默认是 '50%'，由于标签尺寸为 1px * 1px，所以参数其实只有 '50%' 或 '0%' 两个值可选
//	color : 'currentColor',							// 设置波纹的颜色(box-shadow-color)，默认是 'currentColor'，也就是使用 'xj-ripple' 标签的 'color' 属性颜色，支持所有颜色属性值的写法
//	
//	width : 'auto',									// 波纹的宽度，默认是 'auto'，默认的值将会覆盖到容器的边缘，可设置为 '8px' 或 '20%' 等，这里支持 'px' 和 '%' 的单位
//	height : 'auto',								// 波纹的高度，默认是 'auto'，默认的值将会覆盖到容器的边缘，可设置为 '8px' 或 '20%' 等，这里支持 'px' 和 '%' 的单位
//	
//	minWidth : '0px',								// 波纹的最小宽度，默认是 '0px'，也就是不设置，这里支持 'px' 和 '%' 单位，注意不要大于 maxWidth
//	minHeight : '0px',								// 波纹的最小高度，默认是 '0px'，也就是不设置，这里支持 'px' 和 '%' 单位，注意不要大于 maxHeight
//	
//	maxWidth : 'none',								// 波纹的最大宽度，默认是 'none'，也就是不设置，这里支持 'px' 和 '%' 单位，注意不要小于 minWidth
//	maxHeight : 'none',								// 波纹的最大高度，默认是 'none'，也就是不设置，这里支持 'px' 和 '%' 单位，注意不要小于 minHeight
//	
//	extraWidth : '0px',								// 波纹的额外宽度，默认是 '0px'，也可以是负值，这里支持 'px' 和 '%' 单位，用于额外的添加或减去尺寸
//	extraHeight : '0px',							// 波纹的额外高度，默认是 '0px'，也可以是负值，这里支持 'px' 和 '%' 单位，用于额外的添加或减去尺寸
//	
//	left : 'auto',									// 设置波纹圆心的 X 轴位置，默认是 'auto'，既点击处的 X，可以设置为 '10px' 或 '20%' 等，这里支持 'px' 和 '%' 的单位
//	top : 'auto',									// 设置波纹圆心的 Y 轴位置，默认是 'auto'，既点击处的 Y，可以设置为 '10px' 或 '20%' 等，这里支持 'px' 和 '%' 的单位
//	
//	offsetLeft : '0px',								// 波纹定位 X 轴偏移值，默认是 '0px'，可设置为负值如 '-10px'，正数往右偏移，负数往左偏移，这里支持 'px' 和 '%' 单位
//	offsetTop : '0px',								// 波纹定位 Y 轴偏移值，默认是 '0px'，可设置为负值如 '-10px'，正数往下偏移，负数往上偏移，这里支持 'px' 和 '%' 单位
//	
//	transitionProperty : 'transform, opacity',		// 波纹过渡动画的属性，默认是 'transform, opacity'
//	transitionDuration : '500ms',					// 波纹过渡动画的时长，默认是 '500ms'
//	transitionTimingFunction : 'ease-out',			// 波纹过渡动画的缓动，默认是 'ease-out'
//	transitionDelay : '0ms, 125ms',					// 波纹过渡动画的延迟，默认是 '0ms, 125ms'
//	
//	specialRatio : 1.5,								// 当波纹以 specialClass 模式响应时尺寸的设置，默认为 1.5，也就是容器最长那条边的 1.5 倍，可确保波纹能覆盖到容器的边缘，也可根据需要设置成其它值
//	
//	createBefore : pub_nothing,						// 波纹写入前执行的函数，第一个参数 event 是事件对象，第二个参数是将被插入的 ripple 波纹节点 
//	createAfter : pub_nothing,						// 波纹写入后执行的函数，第一个参数 event 是事件对象，第二个参数是已被插入的 ripple 波纹节点 
//	
//	removeCallback : pub_nothing,					// 移除波纹前执行的回调，第一个参数 event 是事件对象，第二个参数是已被移除的 ripple 波纹节点
//	
//	// 波纹要插入的位置，默认为 'auto' 既 ripple 波纹将会作为目标节点的直接子元素，但是 ripple 波纹也可以插入到其它位置去的
//	// 这里也可以接受一个函数，函数的参数是 target 节点，你可以使用这个参数自行找到要插入的目标，然后在函数中返回找到的节点
//	// 如果参数不是以 self 或 parent 开头，会用 document.querySelector() 方法选择元素节点，然后将波纹插入到选中的目标节点中
//	// 参数以 parent 开头，例如 'parent div button'，将会转成 target.parentElement.querySelect('div button');
//	// 参数以 self 开头，例如 'self div button'，将会转成 target.querySelector('div button');
//	insertTarget : 'auto',
//	
//};



// 插入无缓存的 link 节点
window.insertLink = function(option){
	var link = document.createElement('link');
	if(option.error){ link.error = option.error };
	if(option.onload){ link.onload = option.onload };
	if(option.type === undefined){ link.type = 'text/css' };
	if(option.rel === undefined){ link.rel = 'stylesheet' };
	if(option.href){ link.href = option.href + (/\?/.test(option.href) ? '' : '?') + 'timeStamp=' + Date.now() };
	document.body.appendChild(link);
};

// 插入无缓存的 script 节点
window.insertScript = function(option){
	var script = document.createElement('script');
	if(option.error){ script.error = option.error };
	if(option.onload){ script.onload = option.onload };
	if(option.type === undefined){ script.type = 'text/javascript' };
	if(option.charset === undefined){ script.charset = 'utf-8' };
	if(option.src){ script.src = option.src + (/\?/.test(option.src) ? '' : '?') + 'timeStamp=' + Date.now() };
	document.body.appendChild(script);
};



// 动态的加载插件，避免有缓存
window.insertLink({href : '../dist/xj.ripple.css', onload : function(){
window.insertScript({src : '../dist/xj.ripple.js', onload : function(){

// 没使用 requirejs 或 seajs 进行模块化时，可以使用全局中的 xj.ripple 对象
// 否则就是 require(['xj.ripple'], function(xr){ console.log(xr) }) 这样了
console.log(xj.ripple);

// create() 方法的两个参数分别是 target, options，前者为波纹所在元素节点，后者为波纹参数设置对象
// 以这种方式创建出来的波纹，默认圆心位置是目标节点的中心点，目标节点得不是 position:static 才行
// {
// 	version : '0.3.0',			// 当前插件和配置的版本号
// 	create : function(){},		// 传入节点和参数生成波纹
// }

}});
}});
</script>



</body>
</html>


